---
import type { ContainerProps } from '../../types/container.types';

const props = Astro.props as ContainerProps;
const ContainerTag = props.htmlTag ?? 'section';
const containerWidthType = props.containerWidthType ?? 'full';
const contentWidthType = props.content?.widthType ?? 'boxed';
const contentBoxWidth = props.content?.boxWidth ?? 'max-w-[var(--container-max-width)]';
const widthClass = props.width ?? '';
const minHeightClass = props.minHeight ?? '';
const items = props.items ?? [];
const equalHeight = props.equalHeight ?? false;
const overflow = props.overflow ?? undefined;
const containerClassName = props.containerClass ?? '';
const contentClassName = props.content?.class ?? '';

const backgroundClass = props.background?.class ?? '';
const backgroundImage = props.background?.image ?? '';
const backgroundVideo = props.background?.video ?? '';
const backgroundAttachment = props.background?.attachment ?? 'scroll';

let containerClass = backgroundClass ? backgroundClass + ' ' : '';
if (containerWidthType === 'boxed') {
  containerClass += 'mx-auto max-w-[var(--container-max-width)] ';
} else if (containerWidthType === 'custom') {
  containerClass += 'mx-auto ';
}
if (widthClass) {
  containerClass += `${widthClass} `;
}
if (minHeightClass) {
  containerClass += `${minHeightClass} `;
}
// Add background utilities when there's a background image
if (backgroundImage) {
  if (!backgroundClass.includes('bg-')) {
    containerClass += 'bg-cover bg-center ';
  }
  if (backgroundAttachment === 'fixed') {
    containerClass += 'bg-fixed ';
  }
}
if (overflow) {
  containerClass += ` overflow-${overflow}`;
}
if (props.spacing?.padding) {
  containerClass += ` ${props.spacing.padding}`;
}
if (props.spacing?.margin) {
  containerClass += ` ${props.spacing.margin}`;
}
if (props.spacing?.gap) {
  containerClass += ` ${props.spacing.gap}`;
}
if (props.border?.width) {
  containerClass += ` ${props.border.width}`;
}
if (props.border?.color) {
  containerClass += ` ${props.border.color}`;
}
if (props.border?.radius) {
  containerClass += ` ${props.border.radius}`;
}
if (containerClassName) {
  containerClass += containerClassName;
}

// Build inline styles (dynamic background-image URL)
let containerStyle = 'position:relative;';
if (backgroundImage && !Astro.slots.background) {
  containerStyle += `background-image:url('${backgroundImage}');`;
}

let contentClass = 'w-full relative z-1';
if (containerWidthType === 'full') {
  if (contentWidthType === 'boxed') {
    contentClass += ` ${contentBoxWidth} mx-auto`;
  } else if (contentWidthType === 'full') {
    contentClass += ' w-full';
  }
}
if (props.content?.spacing?.padding) {
  contentClass += ` ${props.content.spacing.padding}`;
}
if (props.content?.spacing?.margin) {
  contentClass += ` ${props.content.spacing.margin}`;
}
if (props.content?.spacing?.gap) {
  contentClass += ` ${props.content.spacing.gap}`;
}
if (props.content?.border?.width) {
  contentClass += ` ${props.content.border.width}`;
}
if (props.content?.border?.color) {
  contentClass += ` ${props.content.border.color}`;
}
if (props.content?.border?.radius) {
  contentClass += ` ${props.content.border.radius}`;
}
if (contentClassName) {
  contentClass += ` ${contentClassName}`;
}
if (equalHeight) {
  contentClass += ' items-stretch';
}
---

<ContainerTag class={containerClass.trim()} style={containerStyle}>
  {
    Astro.slots.background ? (
      <slot name="background" />
    ) : backgroundVideo ? (
      <video
        class="absolute z-0 inset-0 w-full h-full object-cover"
        autoplay
        loop
        muted
        playsinline
        aria-hidden="true"
      >
        <source src={backgroundVideo} type="video/mp4" />
      </video>
    ) : null
  }
  <div class={contentClass.trim()}>
    {
      items && items.length > 0 ? (
        items.map((item) => <div class={item.class} id={item.id} set:html={item.content} />)
      ) : (
        <slot />
      )
    }
  </div>
</ContainerTag>

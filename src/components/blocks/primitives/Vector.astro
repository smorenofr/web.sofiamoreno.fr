---
import type { VectorProps } from '~/types/vector.types';
import { cn } from '~/utils/styles';
import { promises as fs } from 'node:fs';
import path from 'node:path';

type Props = VectorProps;

const {
  src,
  layout = 'responsive',
  width,
  height,
  align,
  class: className = '',
  ariaLabel,
  preserveColors = false,
  ...attrs
} = Astro.props;

// Read SVG content
let svgContent: string = '';

const stripQueryHash = (p: string) => p.split('?')[0].split('#')[0];

try {
  if (typeof src === 'string') {
    const trimmed = src.trim();

    if (trimmed.startsWith('<')) {
      // Already raw SVG string (may start with <?xml or <svg)
      svgContent = trimmed;
    } else if (trimmed.startsWith('/') && !trimmed.startsWith('//')) {
      // Root-relative path: prefer reading from `public/` during build/SSR
      const cleanPath = stripQueryHash(trimmed).replace(/^\//, '');
      try {
        svgContent = await fs.readFile(path.join(process.cwd(), 'public', cleanPath), 'utf-8');
      } catch (fsErr) {
        console.debug('Vector component: public fs read failed', fsErr);
        // If reading from disk fails (e.g. in dev), fallback to HTTP fetch
        try {
          const fetchUrl = new URL(trimmed, Astro.url).href;
          const response = await fetch(fetchUrl);
          if (response.ok) {
            svgContent = await response.text();
          } else {
            console.error(
              `Vector component: Failed to fetch SVG from ${fetchUrl}`,
              response.statusText
            );
          }
        } catch (fetchErr) {
          console.error(`Vector component: Failed to load public SVG ${trimmed}`, fetchErr);
        }
      }
    } else {
      // External URL or relative path - resolve against the current page URL and fetch
      const fetchUrl = new URL(trimmed, Astro.url).href;
      const response = await fetch(fetchUrl);
      if (response.ok) {
        svgContent = await response.text();
      } else {
        console.error(`Vector component: Failed to fetch SVG from ${trimmed}`, response.statusText);
      }
    }
  } else if (src && typeof src === 'object' && 'src' in src) {
    // ImageMetadata from Vite import - try filesystem read for root-relative processed paths,
    // otherwise fetch the processed output path
    const metadataSrc = String((src as { src?: string }).src || '');
    if (metadataSrc.startsWith('/') && !metadataSrc.startsWith('//')) {
      const cleanPath = stripQueryHash(metadataSrc).replace(/^\//, '');
      try {
        svgContent = await fs.readFile(path.join(process.cwd(), 'public', cleanPath), 'utf-8');
      } catch (fsErr) {
        console.debug('Vector component: ImageMetadata fs read failed', fsErr);
        try {
          const response = await fetch(metadataSrc);
          if (response.ok) svgContent = await response.text();
          else
            console.error(`Vector component: Failed to fetch SVG from ImageMetadata`, metadataSrc);
        } catch (err) {
          console.error('Vector component: Failed to load SVG from ImageMetadata', err);
        }
      }
    } else {
      try {
        const response = await fetch(metadataSrc);
        if (response.ok) svgContent = await response.text();
        else console.error(`Vector component: Failed to fetch SVG from ImageMetadata`, metadataSrc);
      } catch (err) {
        console.error('Vector component: Failed to load SVG from ImageMetadata', err);
      }
    }
  }
} catch (error) {
  console.error('Vector component: Failed to load SVG', error);
}

// Process SVG content - only handle colors and essential attributes
if (svgContent) {
  // Replace fill/stroke colors with currentColor (unless preserveColors is true)
  if (!preserveColors) {
    svgContent = svgContent.replace(/fill="(?!none")[^"]*"/g, 'fill="currentColor"');
    svgContent = svgContent.replace(/stroke="(?!none")[^"]*"/g, 'stroke="currentColor"');
    svgContent = svgContent.replace(/fill:\s*#[0-9a-fA-F]{3,8}/g, 'fill: currentColor');
    svgContent = svgContent.replace(/stroke:\s*#[0-9a-fA-F]{3,8}/g, 'stroke: currentColor');
  }

  // Remove width/height attributes to allow CSS control (this is necessary)
  svgContent = svgContent.replace(/\s*width="[^"]*"/gi, '');
  svgContent = svgContent.replace(/\s*height="[^"]*"/gi, '');

  // Add aria-label if provided
  if (ariaLabel) {
    svgContent = svgContent.replace('<svg', `<svg aria-label="${ariaLabel}" role="img"`);
  }
}

// Build wrapper classes based on layout
const wrapperClasses = cn(
  'vector-wrapper',
  // Layout classes
  {
    responsive: 'w-full h-full flex items-center justify-center',
    fixed: 'inline-flex',
    intrinsic: 'inline-flex',
    fill: 'w-full h-full flex',
  }[layout],
  // Alignment (only for non-fill layouts)
  layout !== 'fill' && align === 'center' && 'justify-center',
  layout !== 'fill' && align === 'right' && 'justify-end',
  layout !== 'fill' && align === 'left' && 'justify-start',
  className
);

// Build inline styles
const wrapperStyle =
  layout === 'fixed' && (width || height)
    ? `width: ${typeof width === 'number' ? `${width}px` : width || 'auto'}; height: ${typeof height === 'number' ? `${height}px` : height || 'auto'};`
    : '';
---

{
  !svgContent ? (
    <Fragment />
  ) : (
    <div class={wrapperClasses} style={wrapperStyle} {...attrs} set:html={svgContent} />
  )
}

<style>
  .vector-wrapper :global(svg) {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>

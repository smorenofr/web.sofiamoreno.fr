---
import type { HTMLAttributes } from 'astro/types';
import { findImage } from '~/utils/images';
import {
  getImagesOptimized,
  astroAssetsOptimizer,
  unpicOptimizer,
  isUnpicCompatible,
  type ImageProps as Props,
} from '~/utils/images-optimization';

type ImageType = {
  src: string;
  attributes: HTMLAttributes<'img'>;
};

// Extract props
const props = Astro.props;

// Validate required props
if (props.alt === undefined || props.alt === null) {
  throw new Error('Image component requires an alt attribute for accessibility');
}

if (typeof props.width === 'string') {
  props.width = parseInt(props.width);
}

if (typeof props.height === 'string') {
  props.height = parseInt(props.height);
}

if (!props.loading) {
  props.loading = 'lazy';
}

// Build alignment class
const align = props.align;
const alignClass =
  align === 'center'
    ? 'flex justify-center'
    : align === 'right'
      ? 'flex justify-end'
      : align === 'left'
        ? 'flex justify-start'
        : '';

// For contained and cover layouts, wrapper needs full dimensions
const wrapperClass =
  props.layout === 'contained' || props.layout === 'cover'
    ? `${alignClass} w-full h-full`
    : alignClass;

if (!props.decoding) {
  props.decoding = 'async';
}

const _image = await findImage(props.src);

let image: ImageType | undefined = undefined;

if (
  typeof _image === 'string' &&
  (_image.startsWith('http://') || _image.startsWith('https://')) &&
  isUnpicCompatible(_image)
) {
  image = await getImagesOptimized(_image, props, unpicOptimizer);
} else if (_image) {
  image = await getImagesOptimized(_image, props, astroAssetsOptimizer);
}
---

{
  !image ? (
    <Fragment />
  ) : (
    <div class={wrapperClass}>
      <img src={image.src} referrerpolicy="no-referrer" {...image.attributes} />
    </div>
  )
}
